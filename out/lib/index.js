// Generated by CoffeeScript 1.9.0
"use strict";
var Index, assert, co, compose, events, http, thunkify,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  __hasProp = {}.hasOwnProperty,
  __slice = [].slice;

http = require('http');

co = require('co');

assert = require('assert');

compose = require('koa-compose');

events = require('events');

thunkify = require('thunkify');

Index = (function(_super) {
  __extends(Index, _super);

  function Index() {
    return Index.__super__.constructor.apply(this, arguments);
  }

  Index.prototype.middleware = [];

  Index.prototype.listen = function() {
    var app, args, middleware;
    args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
    middleware = this.middleware;
    app = http.createServer(this.callback());
    return app.listen.apply(app, args);
  };

  Index.prototype.callback = function() {
    var fn, gen, middleware, respond;
    respond = this.respond, middleware = this.middleware;
    gen = compose(middleware);
    fn = co.wrap(gen);
    return (function(_this) {
      return function(req, res) {
        return fn.call({
          req: req,
          res: res
        })["catch"](_this.onerror(req, res));
      };
    })(this);
  };

  Index.prototype.onerror = function(req, res) {
    return (function(_this) {
      return function(error) {
        var code, headers, message, status, _ref;
        assert(error instanceof Error, "non-error thrown: " + error);
        _this.emit('error', error);
        try {
          console.error('=========catched error============');
          console.log(error.message, error.stack);
          console.error('==================================');
        } catch (_error) {}
        if (!res.writable) {
          return console.warn('response was not able to write, so ignore it!');
        } else {
          status = 500;
          _ref = error || {}, message = _ref.message, code = _ref.code;
          if ('ENOENT' === code) {
            status = 404;
          }
          res.status = status;
          if (message == null) {
            message = 'some thing wrong';
          }
          headers = {
            "Content-Length": Buffer.byteLength(message),
            "Content-Type": "text/plain"
          };
          res.writeHeader(status, headers);
          return res.end("" + message);
        }
      };
    })(this);
  };

  Index.prototype.use = function(wm) {
    var fn;
    assert(wm && 'fucntion' !== typeof wm, 'app.use() requires a function!');
    if ('Function' === wm.constructor.name) {
      wm = thunkify(wm);
    }
    fn = function*(next) {
      var req, res;
      req = this.req, res = this.res;
      if ('GeneratorFunction' === wm.constructor.name) {
        return (yield wm(req, res, next));
      } else {
        (yield wm(req, res));
        return (yield next);
      }
    };
    this.middleware.push(fn);
    return this;
  };

  Index.prototype.respond = function*(next) {
    res.setHeader('Server: Cover');
    return (yield next);
  };

  return Index;

})(events.EventEmitter);

module.exports = function() {
  return new Index;
};
